---
title: "Agreements"
author: "James Hollway"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Agreements}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## Outlining the problem

One of the central problems in ensembled data packages is 
setting equivalences between observations from different datasets.
This is a central problem because it is what enables us to _relate_ datasets
to one another.

What is required is some classificatory scheme so that same is recognised as same
and different observations are recognised as different.
In many cases, it is useful to have some kind of registry of unique units
that existing and, importantly, new data can be read against.

There are several important features of such a registry that,
while not _required_ are certainly very helpful:

1. **Authoritative**: the registry should be a singular source
1. **Comprehensivity**: the registry should ideally cover all possible units
1. **Succinct**: the registry codes should be as short as possible
1. **Intelligible**: the registry codes should be as meaningful for humans as possible

For some databases, unique identifiers are not too much of a problem because
there exists a relatively comprehensive, authoritative, succinct, and intelligible registry.
An example of this is the central `states` database in the `{qStates}` package.
Here we can rely on ISO-3166 alpha-3 codes for most modern states,
complementing them with COW or other codes for more historical states.
This combined registry is made available through the `qStates::code_states()` function.

But we are not aware of comprehensive, authoritative, succinct, and intelligible registry of treaties.
To solve this problem, we need to think both about how observations might be coded
and what this codes might represent.

## Setting up the problem

To test different solutions to the problem, 
we construct a sample of treaty titles from three different datasets in the `qEnviron::agreements` database.
Let's take only titles of treaties established in a particular decade, the 1980s, 
so that we can increase the probability of matches. 

```{r data, warning=FALSE, message=FALSE}
library(qCreate)
samples <- lapply(qEnviron::agreements[1:3], function(x) x[x$Beg > "1980-01-01" & x$Beg < "1990-01-01", ])
titles <- unlist(purrr::map(samples, "Title"))
titles <- na.omit(titles)
titles <- qCreate::standardise_titles(titles)
titles <- data.frame(titles)
dates <- lubridate::as_date(unlist(purrr::map(samples, "Beg")))
dates <- na.omit(lubridate::as_date(dates))
agreements <- data.frame(cbind(titles, dates))
agreements <- agreements[order(dates),]
agreements <- head(agreements, 200)
```

## Options for solutions

### A perfect match

The sample has been hand coded so that the exact number of agreements that are duplicates or linked to one another is known. 
If we use the hand coded duplicates to correctly identify all duplicates in the sample, we get a perfect match! 
That is, we identify all true positives and no false positives.
The rates of true positives and false positives are represented the receiver operating characteristics (ROC) graph below. 
The area under the curve (AUC score), in dark grey, in the graph is maximized (equals 1). 

```{r hand-code, warning=FALSE, message=FALSE}
library(readr)
library(WVPlots)
hand_coded_sample <- read_delim("hand-coded-sample2.csv", ";", escape_double = FALSE, trim_ws = TRUE)
hand_coded_sample <- dplyr::select(hand_coded_sample, "duplicate", "Linkage")
agreements <- cbind(agreements, hand_coded_sample) %>%
  dplyr::mutate(dates = qCreate::standardise_dates(dates))
WVPlots::ROCPlot(agreements, "duplicate", "duplicate", 1, title = "Duplicates Match")
# WVPlots::PRPlot(agreements, "duplicate", "duplicate", 1, title = "Duplicates Match")
# Precision recall (PR) plots are also available for comparing solutions.
```

In reality, we often do not get a perfect score as we rarely know all the true duplicates across several large datasets.

### Everything unique

First we could simply offer a unique code for each title, no duplicates.
Obviously this would generate errors on the side of false negatives 
for many titles that are quite obviously (for humans) equivalent.
That is, we would find zero false positives as well as zero true positives, as the ROC plot illustrates.

```{r unique, warning=FALSE, message=FALSE}
agreements$unique <- 0
WVPlots::ROCPlot(agreements, "unique", "duplicate", 1, title = "Unique")
# WVPlots::PRPlot(agreements, "unique", "duplicate", 1, title = "Unique")
```

### Random

If we randomly create a variable with 200 values and use it to find duplicates, the AUC scores marginally. 
The ROC plot illustrates how some true positives as well as a few false positives are matched.

```{r random, warning=FALSE, message=FALSE}
agreements$random <- runif(200)
WVPlots::ROCPlot(agreements, "random", "duplicate", 1, title = "Random")
# WVPlots::PRPlot(agreements, "random", "duplicate", 1, title = "Random")
# PR results also illustrate well how Unique duplicate matches work.
```

### Strict match

Here we only consider equivalent those titles that are exactly the same as one another.

```{r strict, warning=FALSE, message=FALSE}
agreements$strict <- ifelse(duplicated(agreements$titles) | 
                                  duplicated(agreements$titles, fromLast = TRUE), 1, 0)
WVPlots::ROCPlot(agreements, "strict", "duplicate", 1, title = "Strict")
# WVPlots::PRPlot(agreements, "strict", "duplicate", 1, title = "Strict")
# PR plot is consistent with ROC plot and shows little improvement from a random match.
```

Note that the AUC probably boosted by our use of `qCreate::standardise_titles()` in qPackages,
but misses a number of more problematic cases.
For example a "Treaty Of..." and "Treaty For..." would be considered distinct,
as would "Antarctic Treaty" and "Antarctic Treaty 1959",
even though they ought to be rendered equivalent.
Strict match is very specify, but not very sensible, as it generates no false positives but it only captures a so many of the true positives.

### Fuzzy match

Fuzzy matching relies on `stringdist` to match observations that are mostly similar but not identical.

```{r fuzzy, warning=FALSE, message=FALSE}

library(fuzzyjoin)
# Match the agreements titles that are from 0 to 15 letters difference
fuzzy <- fuzzyjoin::stringdist_left_join(agreements, agreements, by = "titles", max_dist = 15, distance_col = "dist")


fuzzy <- fuzzy %>%
  dplyr::filter(dist > 0) %>% # Take only the match from 1 to 15 as the strict duplicates are already identified
  dplyr::select(titles.x) %>% # Select the first column of titles that had a match
  dplyr::mutate(fuzzy = "1") %>% # Assign the number 1 which represents a match
  dplyr::distinct() %>%
  dplyr::rename(titles = `titles.x`)

# Join the titles that had a fuzzymatch with the agreements dataset
agreements <- dplyr::left_join(agreements, fuzzy, by = "titles") 

# Complete the new fuzzy column with strict match = 1 also and for the rest, 0
agreements <- agreements %>%
  dplyr::mutate(fuzzy = ifelse(is.na(agreements$fuzzy), "0", 1)) %>% 
  dplyr::mutate(fuzzy = as.numeric(ifelse(strict == 1, 1, fuzzy)))


WVPlots::ROCPlot(agreements, "fuzzy", "duplicate", 1, title = "Fuzzy")
# WVPlots::PRPlot(agreements, "fuzzy", "duplicate", 1, title = "Fuzzy")
# Improvements are also visible in the PR plot. 
```

There are some important advantages here, as the ROC plot illustrates by the increased amount of duplicates found. However:

1. is computationally expensive/takes a long time
2. errors on the side of false positives depending on the distance specification

### Identifying information extraction

Another option is to extract key identifying information from the titles and dates,
rendering as equivalent any titles that have the same key identifying information.

The question here is which information to extract from the titles.
It needs to be enough information to render as distinct those titles that are indeed distinct,
but that ignores both less salient information (e.g. "Of" versus "For")
and addenda (e.g. the year at the end of the treaty title).

The less information we require for a match, the higher the false positive rate,
and the more information we require, the higher the false negative rate.

Using our current version of `{qCreate}` we obtain:

```{r qid, warning=FALSE, message=FALSE}
agreements$qID <- qCreate::code_agreements(agreements, agreements$titles, agreements$dates)
agreements$idinfo <- ifelse(duplicated(agreements$qID) | 
                                  duplicated(agreements$qID, fromLast = TRUE), 1, 0)
WVPlots::ROCPlot(agreements, "idinfo", "duplicate", 1, title = "qID Strict")
# WVPlots::PRPlot(agreements, "idinfo", "duplicate", 1, title = "qID Strict")
# PR plot illustrate similarities betwwen a perfect match and qID match.
```

Not only `code_agreements()` finds duplicates more accurately, it also references the type of treaty an observation
is and to which other observations they are linked to. 
We can also improve the AUC scores by fuzzy matching the new qIDs generated by `code_agreements()`

```{r qsim, warning=FALSE, message=FALSE}
# qsim <- stringdist::stringsimmatrix(agreements$qID, agreements$qID)

qsim <- fuzzyjoin::stringdist_left_join(agreements, agreements, by = "qID", max_dist = 2, distance_col = "dist")

qsim <- qsim %>%
  dplyr::filter(dist > 0) %>% # Take only the match from 1 to 2
  dplyr::select(titles.x) %>% # Select the first column of titles that had a match
  dplyr::mutate(qsim = "1") %>% # Assign the number 1 which represents a match
  dplyr::distinct() %>% # Get rido of the duplicate in the column
  dplyr::rename(titles = `titles.x`)

# Join the qID that had a fuzzymatch of max.dist 2 with other qID
agreements <- dplyr::left_join(agreements, qsim, by = "titles") 

# Complete the new qsim column with values from idinfo also and for the rest, 0
agreements <- agreements %>%
  dplyr::mutate(qsim = ifelse(is.na(agreements$qsim), "0", 1)) %>% 
  dplyr::mutate(qsim = as.numeric(ifelse(idinfo == 1, 1, qsim)))

# diag(qsim) <- 0
# agreements$qsim <- apply(qsim, 1, max)
WVPlots::ROCPlot(agreements, "qsim", "duplicate", 1, title = "qID Sim")
# WVPlots::PRPlot(agreements, "qsim", "duplicate", 1, title = "qID Sim")
# Better than above!
```

### Comparing specificity versus sensitivity

We can compare the specificity versus sensitivity for each of the possible solutions discussed above in the same ROC plot. 

```{r comparison, warning=FALSE, message=FALSE}
WVPlots::ROCPlotList(frame = agreements, xvar_names = c("strict", "fuzzy", "idinfo", "qsim"), 
                     truthVar = "duplicate", truthTarget = TRUE, title = "Comparing the different solutions")
```

## How to read a qID

A qID is a meaningful shorthand ID created from a combination of elements extracted from the agreement title and date. 
The qID allows users to identify date, type and linkage.

**Type** | **Pasting** | **Pasting**
--- | --- |--- 
Bilateral | MEX-USA[8]_1906A | parties[number of words]_uID(type)
Bilateral + Protocol | RUS-USA[17]_1971P[FI]:[17]_1967A[FI] | parties[number of words]_uID(type)[action]:linkage

A bilateral treaty that is an agreement will have the following qID: "MEX-USA_1906A". 
This is a combination of the parties to agreement (MEX-USA) with the year of signature (1906) 
followed by the type (A = Agreement.
A bilateral treaty that is any other type than an agreement (e.g. protocol, amendments) will have 
the qID under this format: "RUS-USA[17]_1971P[FI]:[17]_1967A[FI]". 
It is composed of the parties (RUS-USA), the number of words that are contained in the treaty
title (17) when common words (e.g. "of", "the", or "for") are ignored, the year of signature 
of the protocol (1971), the type (P) which refers to Protocol.
The action [FI] which stands for "fishing" is only added in the qID when other treaties from the same 
parties signed other treaties on the same year because it allows to differentiate them. Finally, the linkage 
part is linking the agreement to its "mother" treaty qID but without repeating the 
parties ([17]_1967A[FI]).

**Type** | **Pasting** | **Pasting**
--- | --- |--- 
Multilateral | HSPDF_2005A | acronym_uID(type)
Multilateral + Protocol | SFDP_2007E2:H08F_1992A | acronym, uID,type(number):linkage

A multilateral treaty that is an agreement will have the following qID: "HSPDF_2005A" which 
indicates the acronym (HSPDF), the signature year of the agreement (2005) and the type (A). 
A multilateral treaty that is not an agreement will have this qID format: "SFDP_1992E2:H08F_2007". 
This represents the acronym (SFDP), the signature year of the amendment (20070817), the type (E = Amendment),
the number of amendment (2) and the linkage number (H08F_2007) of the "mother" treaty. 

**Type** | **Pasting** | **Pasting**
--- | --- |--- 
Known treaties | 	UNCLOS1982A | abbreviation, uID, type
Amendment of known treaties | J09H_1990E2:MARPOL1973A | acronym_uID,type(number):linkage

Famous multilateral treaties have a simplified qID with a known abbreviation. 
For example, the United Nations Convention On The Law Of The Sea will have the following qID: "UNCLOC1982A". 
This is the known abbreviation (UNCLOS) and the signature year (1982) with the type (A). 
The protocols or amendments of the known treaties will have this qID format: "J09H_1990E2:MARPOL1973A". 
It indicates the acronym (J09H), the signature year of this specific amendment (1990), the type of treaty (E),
its number (2) and the qID of the "mother" treaty (MARPOL197A).

## How `code_agreements()` work

The function extracts important information from treaty titles and dates at each step of the way to make sure duplicates are actual duplicates.
As well as to correctly identify linkages between treaties.   

### Parties

The first element extracted from the title is the state that is part to the treaty. 
The function `code_states()` from `qStates` is used. It returns 3 digit ISO codes for states.
The function `code_parties()`returns the states' abbreviation only when two states 
are identified in the title. Then, the number in brackets pasted next to the parties
indicate the number of "important" words in the title. The common words like "of", "the",
"to", etc are ignored in the counting. 

```{r parties, eval=FALSE}
qCreate::code_parties(agreements$titles)
```

### Acronyms

All the multilateral treaties start with the acronyms generated by the `code_acronym()` function. 
It extracts letters from the title once specific words, numbers and special characters 
are deleted from the title. Some of the acronyms might contains some numbers if the title exceed 
a certain length.

```{r parties, eval=FALSE}
qCreate::code_acronym(agreements$titles)
```

### Date

Each treaty contains a unique number in their qID which refer to the signature year (called 
"uID"). 
The number has therefore four numbers which refers to the year only, under YYYY format. 
In some cases, the year of signature for multiple bilateral or multilateral treaties
fall on the same year.
In those cases, the unique number will also contain the abbreviation for the action
extracted from the treaty title.
Actions are abbreviations for the function of agreement (usually from verbs in title).
To see the complete list of actions and their attached abbreviation, please run `code_action()`.

```{r dates, eval=FALSE}
qCreate::code_dates(agreements$dates)
```

### Type

The function detects the type of treaty and assign a letter that will be included in the final qID. 

```{r type, eval=FALSE}
qCreate::code_type(agreements$titles)
```

* Agreements = **A**
* Amendments = **E**
* Protocol = **P**
* Notes = **N**
* Resolutions = **R**
* Strategy = **S**

To see which key words are used to identify the treaty type, please run `code_type()`.
For amendments or protocol, their ordering number, if present, is also extracted from the title to be included in the qID. 

### Known Agreements

Are these a famous agreements for which abbreviations are known? 
Some treaties already have known abbreviation. 
The qID of these treaties contain their abbreviation and signature year.


```{r known, eval=FALSE}
qCreate::code_known_agreements(agreements$titles)
```

**Know Agreements** | **Abbreviation**
--- | ---
"United Nations Convention On The Law Of The Sea" | UNCLOS1982
"Convention On Biological Diversity" | CBD1992
"Convention On The Conservation Of Antarctic Marine Living Resources" | CCAMLR1980
"Convention On International Trade In Endangered Species Of Wild Fauna And Flora" | CITES1973
"International Convention On Civil Liability For Oil Pollution Damage" | CLC1969
"International Convention For The Prevention Of Pollution From Ships" | MARPOL 1973
"Constitutional Agreement Of The Latin American Organization For Fisheries Development" | OLDEPESCA1982
"Paris Agreement Under The United Nations Framework Convention On Climate Change" | PARIS2015
"Convention On Wetlands Of International Importance Especially As Waterfowl Habitat" | RAMSA1971
"United Nations Framework Convention On Climate Change" | UNFCCC1992

For the complete list of coded known agreement, please run the following function
without any argument: `code_known_agreements()`.

### Linkage

Detects the family a treaty might belong to. 
Treaties from the same family can be detected by removing predictable words that are added to treaty titles 
(e.g. amendment, protocol, meeting) and identifying duplicates based on the key words used to refer to main agreement. 
The qID assigned to the "mother" treaty is used for all the other treaties deriving from it as the last digits in their qID.

```{r linkage, eval=FALSE}
qCreate::code_linkage(agreements$titles, agreements$dates)
```

Once added together the information extracted from treaty title and date 
forms a qID which is more authoritative, comprehensible, succinct and 
intelligible than other conventions.
